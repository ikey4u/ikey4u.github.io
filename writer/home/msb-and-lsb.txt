---
Title: MSB vs LSB
Date: 2018-12-22
Author: bugnofree
---

MSB 和 LSB 其实是有歧义的, 可以代表 MSBit, MSByte 或者 LSBit, MSByte.
这里分别介绍一下.

# MSByte 和 LSByte

对于这种情况, 大家通常说的是端序问题.
当一个数值类型占据的位数大于一个字节时, 哪一边的字节权重更高就成了一个需要解决的问题.

假设一个整数 p 有 4 个字节, 那么这 4 个字节依次存放在内存位置
`[addr, addr + 4)` 处. 那么这个整数的地址则是 addr,
我们可以认为计算机读的时候总是从低地址向高地址读 4 个字节,
根据其规定的机器端序, 边读边解释.

假如是 MSByte(即大端序), 那么最低地址的权重就最大,
那么计算机就需要多计算一下最高权重的权重值, 而这会增加资源消耗,
不管怎么说, 总是能得到最高的权重值, 然后每读一个字节就累加依次, 得到结果.
如果我们从低地址向高地址看去, 和我们人类的习惯是颇为相似的:

    LA   →  HA
    -----------
    12 34 56 78

分割线上面的表示低地址(LA)到高地址(HA)的视角进行内存字节序列的读取,
得到十六进制值是 0x12345678, 这和我们书写方式一致.

但是 MSByte 并不方便计算机计算, 大多都采用小端序,
小端序在内存中的布局如下

    LA   →  HA
    -----------
    78 56 34 12

计算机也是从 LA 到 HA 读取字节序列, 但是权重值是从 0 开始,
依次 1, 2, 3 ...递增, 没有计算负担, 得到的结果也是 0x12345678.

总的来说, 我们基于 `计算机总是从低地址到高地址读字节序列` 可以很快得出:

- 如果是大端序, 那么第一个字节的权重就最大.
- 如果是小段序, 那么第一个字节的权重就最小.

# MSBit 和 LSBit

这个也是类似的, 不过这里面对应的数据是一串二进制序列.

结论是: 我们基于 `我们总是从左到右读一个 bit 序列` 可以很快得出:

- 如果是 MSBit, 那么第一个 bit 权重最大.
- 如果是 LSBit, 那么第一个 bit 权重最小.

# 参考

- Big Endian and Little Endian @[https://chortle.ccsu.edu/AssemblyTutorial/Chapter-15/ass15_3.html]
- Bit numbering @[https://en.wikipedia.org/wiki/Bit_numbering]
