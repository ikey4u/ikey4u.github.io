#include <stdlib.h>
#include <time.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <inttypes.h>
#include <windows.h>

#define BYTE  uint8_t
#define WORD  uint16_t
#define DWORD uint32_t
#define QWORD uint64_t

DWORD* get_dst_block(DWORD *Dst, signed int idx)
{
  DWORD *result; // rax

  if ( idx >= 0 && idx <= 255 )
    result = &Dst[3 * idx];
  else
    result = 0;
  return result;
}

void sub_4026D0(DWORD *a1, unsigned int a2)
{
  DWORD *result; // rax
  DWORD *v3; // rax
  int v4; // [rsp+24h] [rbp-1Ch]
  DWORD *v5; // [rsp+28h] [rbp-18h]
  DWORD *v6; // [rsp+30h] [rbp-10h]
  DWORD *v7; // [rsp+38h] [rbp-8h]
  DWORD *a1a; // [rsp+50h] [rbp+10h]
  signed int idxa; // [rsp+58h] [rbp+18h]

  a1a = a1;
  idxa = a2;
  result = get_dst_block(a1, a2);
  v7 = result;
  if ( result )
  {
    if ( idxa & 0xF )
      v3 = get_dst_block(a1a, idxa - 1);
    else
      v3 = 0;
    v6 = v3;
    if ( (unsigned int)(idxa + 15) <= 0x1E )
      result = 0;
    else
      result = get_dst_block(a1a, idxa - 16);
    v5 = result;
    if ( v6 || result )
    {
      if ( v6 )
      {
        v7[1] = *(char *)v7 + v6[1];
        result = v7;
        v7[2] = 2 * v6[2];
      }
      if ( v5 )
      {
        v4 = v5[1] + *(char *)v7;
        result = (DWORD *)v7[1];
        if ( v4 < (signed int)result )
        {
          v7[1] = v4;
          result = v7;
          v7[2] = 2 * v5[2] | 1;
        }
      }
    }
    else
    {
      result = v7;
      v7[1] = *(char *)v7;
    }
  }
}

int main()
{
    int min_epoch = 1526720399 + 1;
    int max_epoch = 1526893199;
    BYTE secret[] = {0x58,0x71,0x8f,0x32,0x5,0x6,0x51,0xc7,0xa7,0xf8,0x3a,0xe1,0x6,0x48,0x82,0x9,0xa1,0x12,0x9f,0x7c,0xb8,0x2a,0x6f,0x95,0xfd,0xd0,0x67,0xc8,0xe3,0xce,0xab,0x12,0x1f,0x98,0x6b,0x14,0xea,0x89,0x90,0x21,0x2d,0xfd,0x9a,0xbb,0x47,0xcc,0xea,0x9c,0xd7,0x50,0x27,0xaf,0xb9,0x77,0xdf,0xc5,0xe9,0xe1,0x50,0xd3,0x38,0x89,0xef,0x2d,0x72,0xc2,0xdf,0xf3,0x7d,0x7d,0x65,0x95,0xed,0x13,0x0,0x1c,0xa3,0x3c,0xe3,0x57,0xe3,0xf7,0xf7,0x2c,0x73,0x88,0x34,0xb1,0x62,0xd3,0x37,0x19,0x26,0xbe,0xb2,0x33,0x20,0x3f,0x60,0x39,0x87,0xa6,0x65,0xad,0x73,0x1a,0x6d,0x49,0x33,0x49,0xc0,0x56,0x0,0xbe,0xa,0xcf,0x28,0x7e,0x8e,0x69,0x87,0xe1,0x5,0x88,0xda,0x54,0x3e,0x3c,0xe,0xa9,0xfa,0xd7,0x7f,0x4e,0x44,0xc6,0x9a,0xa,0xd2,0x98,0x6a,0xa4,0x19,0x6d,0x8c,0xe1,0xf9,0x30,0xe5,0xff,0x33,0x4a,0xa9,0x52,0x3a,0xd,0x67,0x20,0x1d,0xbf,0x36,0x3e,0xe8,0x56,0xbf,0x5a,0x88,0xa8,0x69,0xd6,0xab,0x52,0xf1,0x14,0xf2,0xd7,0xef,0x92,0xf7,0xa0,0x70,0xa1,0xef,0xe3,0x1f,0x66,0x2b,0x97,0xf6,0x2b,0x30,0xf,0xb0,0xb4,0xc0,0xfe,0xa6,0x62,0xfd,0xe6,0x4c,0x39,0xcf,0x20,0xb3,0x10,0x60,0x9f,0x34,0xbe,0xb2,0x1c,0x3b,0x6b,0x1d,0xdf,0x53,0x72,0xf2,0xfa,0xb1,0x51,0x82,0x4,0x30,0x56,0x1f,0x37,0x72,0x7a,0x97,0x50,0x29,0x86,0x4a,0x9,0x3c,0x59,0xc4,0x41,0x71,0xf8,0x1a,0xd2,0x30,0x88,0x63,0xff,0x85,0xde,0x24,0x8c,0xc3,0x37,0x14,0xc7};
    DWORD Dst[768];
    BYTE buf[256];
    for(int epoch = min_epoch; epoch <= max_epoch; ++epoch)
    {
        srand(epoch);
        /*
         * Do not write like this(since we are doing force brute....):
         * for(int i = 0; i <= 255; ++i) secret[i] ^= rand();
         * This is the right way:
         * for(int i = 0; i <= 255; ++i) buf[i] = secret[i] ^ rand();
         */
        for(int i = 0; i <= 255; ++i) buf[i] = secret[i] ^ rand();
        memset(Dst,0,0xc00);
        for(int i =0; i <= 255; ++i)
        {
            /*
             * Note that this is a byte assignment, not a DWORD.
             * We could confirm through the corresponding assembly
             * code: "mov [rax], cl". In fact, here is an alignment
             * in 4 bytes.
             */
            Dst[3 * i] = buf[i];
            Dst[3 * i + 1] =  0x7FFFFFFF;
            Dst[3 * i + 2] = 0;
            sub_4026D0(Dst, i);
        }
        DWORD checksum = Dst[766];
        DWORD decryptkey = Dst[767];
        if(checksum == 0x700)
        {
            printf("epoch is found!\n");
            printf("EPOCH = %#x decryptkey = %#x\n", epoch, decryptkey);
            break;
        }
    }
    printf("DONE!\n");
    /*
     * epoch is found!
     * EPOCH = 0x5b00e398 decryptkey = 0x322ce7a4
     * DONE!
     */
    return 0;
}
