<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="UTF-8">
  <title>vim 脚本编程</title>
  <link href="./css/prism.css" rel="stylesheet" />
  <link href="./css/normalize.css" rel="stylesheet" />
  <link href="./css/pigger.css" rel="stylesheet" />
  </head>
  <body>
  <div style="padding:1% 5% 1% 5%">
    <section style="padding-top: 20px; padding-bottom: 5px; color: #fff; text-align: center; background-image: linear-gradient(120deg, #224a73, #0d4027);">
      <div id = "headtitle"> vim 脚本编程 </div>
      <div id = "headinfo"> by bugnofree </div>
      <div id = "lastupdate"> Publish → 2019-01-15 Update → 2019-01-16</div>
    </section>
    
<h1> 基本语法</h1>
<ul><li>标量<pre><code class="language-clike">let name = &#34;Damian&#34;
let height = 165
</code></pre></li><li>列表<pre><code class="language-clike">let interests = [ &#39;Cinema&#39;, &#39;Literature&#39;, &#39;World Domination&#39;, 101 ]
</code></pre></li><li>字典<pre><code class="language-clike">let phone     = { &#39;cell&#39;:5551017346, &#39;home&#39;:5558038728, &#39;work&#39;:&#39;?&#39; }
</code></pre></li><li>变量域<pre><code class="language-clike">g:varname/Global
s:varname/Script
w:varname/Window
t:varname/Tab
b:varname/Buffer
l:varname/The variable is local to the current function
a:varname/The variable is a parameter of the current function
v:varname/The variable is one that Vim predefines
</code></pre><p>    默认情况下, 一个变量如果在一个函数内部, 那么则是 a:varname 类型的,    如果不在函数内部, 那么则默认是全局变量.</p></li></ul>
<ul><li>变量赋值<p>    通过 set 设置的选项也可以通过 let 来设置, 使用方法为: let &amp;{option} = {expr}.    然而一个异常是 pythonthreedll 选项, 你不能通过上述语法来设置,    vim 手册说是为了安全考虑.</p></li></ul>
<ul><li>内置变量<p>    除了用户定义的变量, vim 也提供了许多内置变量, 这些变量可以通过 &amp; 符号来访问</p><pre><code class="language-clike">&amp;varname	: 一个 vim 选项, 默认是访问全局类型的变量
&amp;l:varname	: 局部
&amp;g:varname	: 全局
@varname	: vim 寄存器
$varname	: 环境变量
</code></pre></li></ul>
<ul><li>表达式<p>    常见的表达式有如下几种, 参考模仿即可</p><pre><code class="language-clike">let var=expr let var+=expr let var-=expr let var.=expr
bool?expr-if-true:expr-if-false
bool||bool bool&amp;&amp;bool !bool
expr==expr expr!=expr expr&gt;expr expr&gt;=expr expr&lt;expr expr&lt;=expr
num+num num-num
str.str
num*num num/num num%num
+num -num
</code></pre></li></ul>
<ul><li>控制流<ul><li> for 循环<pre><code class="language-clike">for i in [1, 2, 3, 4]
  let c += i
endfor
</code></pre></li><li>while 循环<pre><code class="language-clike">while c &lt;= 4
  let total += c
  let c += 1
endwhile
</code></pre></li><li>if 语句<pre><code class="language-clike">if &#34;something&#34;
    echom &#34;INDEED&#34;
endif

if 0
    echom &#34;if&#34;
elseif &#34;nope!&#34;
    echom &#34;elseif&#34;
else
    echom &#34;finally!&#34;
endif
</code></pre></li></ul></li></ul>
<ul><li>输入输出<pre><code class="language-clike">echom total
</code></pre></li></ul>
<ul><li>函数<ul><li>获取函数列表<pre><code class="language-clike">:help function-list
</code></pre></li><li>expand 函数        假设当前文件为 ~/notes/python.txt<pre><code class="language-clike">:p		expand to full path
:h		head (last path component removed)
:t		tail (last path component only), 比如 expand(&#34;%:t&#34;) 得到 python.txt
:r		root (one extension removed)
:e		extension only
let @a=expand(&#34;%:p&#34;) ==&gt; 寄存器 a 的值为文件的完整路径
</code></pre></li><li>定义函数,函数格式大致如下<pre><code class="language-clike">function! TheFunc()
    function body ...
endfunction
</code></pre><p>        函数名称以 &nbsp;<code class="language-clike">function!</code>&nbsp; 开始, 其后接着函数名称(函数名首字母必须为大写),        最后以 &nbsp;<code class="language-clike">endfunction</code>&nbsp; 结束, 调用函数使用 &nbsp;<code class="language-clike">:call TheFunc()</code>&nbsp;.</p><p>        一个样例函数如下:</p><pre><code class="language-clike">nnoremap &lt;F11&gt; :call MaxWindows(1, 23, 71, 239)&lt;CR&gt;
function! MaxWindows(x, y, l, c)
    exec &#34;winpos &#34;.a:x.&#34; &#34;.a:y
    exec &#34;set lines=&#34;.a:l
    exec &#34;set columns=&#34;.a:c
endfunction
</code></pre><p>        需要用 a 前缀来表示在作用域里面寻找变量,        set 命令在函数体内无法直接工作, 需要借助 exec 来执行.</p></li></ul></li></ul>
<ul><li>异常处理(try/catch)<pre><code class="language-clike">try
    command ...
catch [pattern]
    [command]
endtry
</code></pre></li></ul>
<h1> 正则表达式</h1>
<p>替换语法如下</p>
<pre><code class="language-clike">:range s[ubstitute]/pattern/string/cgiI
    For each line in the range replace a match of the pattern
    with the string where:
    c Confirm each substitution
    g Replace all occurrences in the line (without g - only first).
    i Ignore case for the pattern.
    I Don&#39;t ignore case for the pattern.
line range:
    number an absolute line number
    .  the current line
    $ the last line in the file
    % the whole file. The same as 1,$
pattern:
    .  any character except new line
    \s whitespace character
    \S non-whitespace character
    \d digit
    \D non-digit
    \x hex digit
    \X non-hex digit
    \o octal digit
    \O non-octal digit
    \h head of word character (a,b,c...z,A,B,C...Z and _)
    \H non-head of word character
    \p printable character
    \P like \p, but excluding digits
    \w word character
    \W non-word character
    \a alphabetic character
    \A non-alphabetic character
    \l lowercase character
    \L non-lowercase character
    \u uppercase character
    \U non-uppercase character
Quantifier
    * matches 0 or more of the preceding characters, ranges or
      metacharacters .* matches everything including empty line
    \+ matches 1 or more of the preceding characters...
    \= matches 0 or 1 more of the preceding characters...
    \{n,m} matches from n to m of the preceding characters...
    \{n} matches exactly n times of the preceding characters...
    \{,m} matches at most m (from 0 to m) of the preceding characters...
    \{n,} matches at least n of of the preceding characters...
        where n and m are positive integers (&gt;0)

Grouping and Backreferences
    &amp; the whole matched pattern
    \L the following characters are made lowercase
    \0 the whole matched pattern
    \U the following characters are made uppercase
    \1 the matched pattern in the first pair of \(\)
    \E end of \U and \L
    \2 the matched pattern in the second pair of \(\)
    \e end of \U and \L
    ...  ...
    \r split line in two at this point
    \9 the matched pattern in the ninth pair of \(\)
    \l next character made lowercase
    ~ the previous substitute string
    \u next character made uppercase
Alternations
    Using &#34;\|&#34; you can combine several expressions into one which
    matches any of its components. The first one matched will be
    used.
    \(Date:\|Subject:\|From:\)
    比如搜索逗号后者句号,可以使用:/\(,\|\.\)
    在逗号或者句号后面加上一个空格,每个都手动进行确认.
    :.,$s/\(,\|\.\)/\1 /gc
    这里替换范围是从当前行到文件末尾,并对捕获组进行引用,也就是
    捕获到逗号或者句号,然后将其加上一个空格后替换.  g表示对每一
    行中所有的匹配都进行替换,c表示每一个匹配都进行逐一确认.
参考:
- @[http://vimregex.com/]
- @[https://github.com/johngrib/vimscript-cheatsheet]
</code></pre>
<h1> 转 pdf 插件编写</h1>
<p>这个插件借助 wkhtmltopdf 工具将 html 转换为 pdf,需要安装该工具并添加到环境变量中, 具体可以参考如下链接</p>
<ul><li><a href="https://github.com/wkhtmltopdf/wkhtmltopdf/releases">https://github.com/wkhtmltopdf/w...</a></li><li><a href="https://wkhtmltopdf.org/usage/wkhtmltopdf.txt">https://wkhtmltopdf.org/usage/wk...</a></li></ul>
<p>插件源码如下</p>
<pre><code class="language-clike">&#34;If user do not have absolute path of wkhtmltopdf set,
&#34;then we regard it as in PATH environment
if exists(&#34;g:html2pdf_exepath&#34;) == 0
    let g:html2pdf_exepath = &#34;wkhtmltopdf&#34;
endif

function! TOpdf()
    let g:file_name = expand(&#39;%:t:r&#39;)
    TOhtml
    wq! /tmp/tmp.html
    call system(g:html2pdf_exepath .
                \&#34; --header-center &#34; .
                \g:file_name .
                \&#34; --header-spacing 3 &#34; .
                \&#34; /tmp/tmp.html &#34; .
                \&#34;PDF@&#34;.g:file_name.&#34;.pdf&#34;)
    call system(&#34;rm -rf /tmp/tmp.html&#34;)
endfunction

command! TOpdf call TOpdf()
</code></pre>
<p>使用命令 &nbsp;<code class="language-clike">:TOpdf</code>&nbsp; 即可将当前文件转换为 PDF, 输出的文件名称由前缀 &nbsp;<code class="language-clike">PDF@</code>&nbsp; 和当前文件名组成,PDF 的标题为当前文件名称(不带后缀).</p>

    <script src="./js/prism.js"></script>
  </div>
  </body>
</html>

